import re
import sys
import json
import traceback

import graphviz
from PyQt5.QtCore import QRegExp
from PyQt5.QtGui import QRegExpValidator, QValidator, QPixmap, QIcon, QPalette, QColor
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QVBoxLayout, QWidget, QLabel, QLineEdit, QComboBox, QPushButton,
    QTreeWidget, QTreeWidgetItem, QMessageBox, QFileDialog, QGraphicsView, QGraphicsScene, QDialog, QStyleFactory,
    QMenu, QAction
)
from PyQt5 import QtCore, QtGui, QtWidgets

import paramiko
from graphviz.quoting import quote
from paramiko.client import SSHClient, AutoAddPolicy
from paramiko.sftp_client import SFTPClient

class ImageViewer(QDialog):
    def __init__(self, image_path):
        super().__init__()
        self.setWindowTitle("Image Viewer")
        QApplication.setStyle(QStyleFactory.create("Fusion"))
        layout = QVBoxLayout()
        image_label = QLabel()
        layout.addWidget(image_label)
        pixmap = QPixmap(image_path)
        image_label.setPixmap(pixmap)
        self.setLayout(layout)


def check_dns_zone(server_ip, zone_name):
    # Ваша функция проверки зоны DNS
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(server_ip, username='aleks', password='12345')

    # Команда для проверки наличия зоны
    zone_command = f"ls /etc/bind/zones/{zone_name}.zone"
    stdin, stdout, stderr = ssh.exec_command(zone_command)
    zone_output = stdout.read().decode().strip()

    # Команда для перезапуска сервиса bind9
    restart_command = "sudo service bind9 restart"
    stdin, stdout, stderr = ssh.exec_command(restart_command)
    restart_output = stdout.read().decode().strip()

    # Команда для проверки статуса сервиса bind9
    status_command = "sudo service bind9 status"
    stdin, stdout, stderr = ssh.exec_command(status_command)
    status_output = stdout.read().decode().strip()

    ssh.close()
    result = f"Статус сервиса bind9:\n{status_output}"
    result += f"Результат проверки зоны {zone_name}:\n"
    result += f"Зона {zone_name}: {'найдена' if zone_output else 'не найдена'}\n"

    return result

class Ui_Ping(object):
    def setupUi(self, Ping):
        Ping.setObjectName("Ping")
        Ping.resize(890, 391)
        self.text_browser = QtWidgets.QTextBrowser(Ping)
        self.text_browser.setGeometry(QtCore.QRect(10, 30, 851, 221))
        self.text_browser.setObjectName("text_browser")
        self.button = QtWidgets.QPushButton(Ping)
        self.button.clicked.connect(self.check_zone)
        self.button.setGeometry(QtCore.QRect(10, 330, 120, 40))

        self.button.setObjectName("button")
        self.name_server = QtWidgets.QLabel(Ping)
        self.name_server.setGeometry(QtCore.QRect(10, 260, 191, 31))
        font = QtGui.QFont()
        font.setFamily("Corbel")
        font.setPointSize(12)
        self.name_server.setFont(font)
        self.name_server.setObjectName("name_server")
        self.line_edit = QtWidgets.QLineEdit(Ping)
        self.line_edit.setGeometry(QtCore.QRect(10, 295, 241, 22))
        self.line_edit.setObjectName("line_edit")

        self.retranslateUi(Ping)
        QtCore.QMetaObject.connectSlotsByName(Ping)

    def retranslateUi(self, Ping):
        _translate = QtCore.QCoreApplication.translate
        Ping.setWindowTitle(_translate("Ping", "Проверка DNS зоны"))
        self.button.setText(_translate("Ping", "Проверить"))
        self.name_server.setText(_translate("Ping", "Название DNS Зоны:"))


    def check_zone(self):
        zone_name = self.line_edit.text()
        server_ip = '192.168.31.159'  # Укажите здесь необходимый IP-адрес удаленного сервера
        result = check_dns_zone(server_ip, zone_name)
        self.text_browser.setText(result)
        print(result)

class DNSZoneEditor(QMainWindow):
    def __init__(self):
        super().__init__()

        self.domain_items = {}  # Dictionary to store domain items

        self.setWindowTitle("DNS Zone Editor")

        QApplication.setStyle(QStyleFactory.create("Fusion"))
        palette = QPalette()
        palette.setColor(QPalette.Window, QColor(225, 230, 237))
        palette.setColor(QPalette.WindowText, QColor(70, 70, 70))
        palette.setColor(QPalette.Base, QColor(255, 255, 255))
        palette.setColor(QPalette.AlternateBase, QColor(240, 245, 252))
        palette.setColor(QPalette.Button, QColor(220, 225, 232))
        palette.setColor(QPalette.ButtonText, QColor(70, 70, 70))
        palette.setColor(QPalette.Highlight, QColor(135, 170, 213))
        palette.setColor(QPalette.HighlightedText, QColor(255, 255, 255))
        QApplication.setPalette(palette)


        # Create line edits
        self.save_button = QPushButton("Save")
        self.save_button.clicked.connect(self.save_zone)
        self.ping_button = QPushButton("Ping")
        self.ping_button.clicked.connect(self.open_ping_window)
        self.json_button = QPushButton("Generate JSON")
        self.json_button.clicked.connect(self.generate_json)
        self.image_button = QPushButton("Open Image")
        self.image_button.clicked.connect(self.open_image_window)

        self.parent_domain_combo = QComboBox()
        self.name_edit = QLineEdit()
        self.type_combo = QComboBox()
        self.value_edit = QLineEdit()

        self.type_combo.addItems(["A", "TXT", "CNAME"])

        self.add_button = QPushButton("Add")
        self.add_button.clicked.connect(self.add_record)

        self.tree_widget = QTreeWidget()
        self.tree_widget.setHeaderLabels(["Domain", "Type", "Value"])

        self.domain_hierarchy = {}

        layout = QVBoxLayout()

        form_layout = QVBoxLayout()
        form_layout.addWidget(QLabel("Parent Domain:"))
        form_layout.addWidget(self.parent_domain_combo)
        form_layout.addWidget(QLabel("Name:"))
        form_layout.addWidget(self.name_edit)
        form_layout.addWidget(QLabel("Type:"))
        form_layout.addWidget(self.type_combo)
        form_layout.addWidget(QLabel("Value:"))
        form_layout.addWidget(self.value_edit)
        form_layout.addWidget(self.add_button)
        form_layout.addWidget(self.ping_button)
        form_layout.addWidget(self.json_button)
        form_layout.addWidget(self.image_button)




        form_widget = QWidget()
        form_widget.setLayout(form_layout)

        layout.addWidget(form_widget)
        layout.addWidget(self.tree_widget)

        layout.addWidget(self.save_button)


        central_widget = QWidget()
        central_widget.setLayout(layout)
        self.setCentralWidget(central_widget)

        self.domain_names = []

        self.tree_widget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.tree_widget.customContextMenuRequested.connect(self.show_context_menu)

    def open_ping_window(self):
        ping_window = QDialog()
        ping_ui = Ui_Ping()
        ping_ui.setupUi(ping_window)
        ping_window.exec_()

    def save_zone(self):
        try:
            # Получите данные из дерева записей
            root = self.tree_widget.invisibleRootItem()
            data = self.get_tree_data(root)

            def dict_to_dns_zone(domain, data):
                # Создайте пустой список для хранения строк записей зоны DNS
                zone_lines = []

                # Пройдитесь по данным и создайте строку записи для каждой записи
                for entry in data:
                    name = entry['name']
                    record_type = entry['type']
                    value = entry['value']
                    zone_line = f"{name} IN {record_type} {value}"
                    zone_lines.append(zone_line)

                return zone_lines

            parent_domain = data[0]['name']
            domain = data[0]['name']
            print(parent_domain)

            zone_file_lines = []
            zone_file_lines.append("$TTL 604800")
            zone_file_lines.append(f"@ IN SOA ns1.{parent_domain}. hostmaster.{parent_domain}. (")
            zone_file_lines.append("    2023052901 ; Serial")
            zone_file_lines.append("    3600       ; Refresh")
            zone_file_lines.append("    1800       ; Retry")
            zone_file_lines.append("    604800     ; Expire")
            zone_file_lines.append("    86400      ; Negative Cache TTL")
            zone_file_lines.append(")")
            zone_file_lines.append(f"@ IN ns ns1.{parent_domain}.")
            zone_file_lines.append("")
            zone_file_lines.append("ns1 IN A 192.168.0.100")
            zone_file_lines.append(f"{parent_domain} IN A 192.168.31.1")

            zone_file_lines.extend(dict_to_dns_zone(domain, data))
            zone_file_content = '\n'.join(zone_file_lines)
            zone_file_content += '\n'

            print(zone_file_content)

            import paramiko

            # SSH connection parameters
            hostname = '192.168.31.159'
            username = 'aleks'
            password = '12345'
            port = 22

            # SSH client initialization
            client = paramiko.SSHClient()
            client.load_system_host_keys()  # Load system host keys
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

            try:
                # Connect to the Ubuntu server
                client.connect(hostname, port, username, password)

                # Remove the existing helloworld.com.zone file if it exists
                _, stdout, stderr = client.exec_command('rm /etc/bind/zones/{}.zone'.format(parent_domain))
                print(stdout.read().decode())
                print(stderr.read().decode())

                # Define the DNS zone content
                dns_zone_content = zone_file_content

                # Create a temporary file to store the DNS zone content
                with open('dns_zone.txt', 'w') as zone_file:
                    zone_file.write(dns_zone_content)

                # Upload the file to the remote server
                transport = client.get_transport()
                sftp = paramiko.SFTPClient.from_transport(transport)
                sftp.put('dns_zone.txt', '/etc/bind/zones/{}.zone'.format(parent_domain))
                sftp.close()

                # Read the content of named.conf.default-zones
                _, stdout, _ = client.exec_command('cat /etc/bind/named.conf.local')
                named_conf_default_zones_content = stdout.read().decode()

                # Check if the zone configuration already exists in named.conf.default-zones
                if f'zone "{parent_domain}.com"' in named_conf_default_zones_content:
                    print('Zone configuration already exists in named.conf.default-zones. Skipping...')
                else:
                    # Add zone configuration to named.conf.default-zones
                    append_command = f'echo \'zone "{parent_domain}" {{ type master; file "/etc/bind/zones/{parent_domain}.zone"; }};\' | sudo -S tee -a /etc/bind/named.conf.local '

                    _, stdout, stderr = client.exec_command(append_command)
                    print(stdout.read().decode())
                    print(stderr.read().decode())

                    # Execute the command to restart the DNS server
                    _, stdout, stderr = client.exec_command('sudo systemctl restart bind9')
                    print(stdout.read().decode())
                    print(stderr.read().decode())

            except Exception as e:
                error_message = f"An error occurred while saving the zone: {str(e)}"
                self.display_error_message(error_message)
                traceback.print_exc()

            finally:
                if client:
                    client.close()

            print(data)  # Пример вывода данных

        except Exception as e:
            error_message = f"An error occurred while saving the zone: {str(e)}"
            self.display_error_message(error_message)
            traceback.print_exc()

    def get_tree_data(self, parent_item):
        data = []
        for i in range(parent_item.childCount()):
            item = parent_item.child(i)
            name = item.text(0)
            record_type = item.text(1)
            value = item.text(2)
            children = self.get_tree_data(item)
            data.append({
                'name': name,
                'type': record_type,
                'value': value,
                'children': children
            })
        return data
    def add_record(self):
        try:
            # Getting values from interface elements
            name = self.name_edit.text()
            record_type = self.type_combo.currentText()
            value = self.value_edit.text()

            # Checking the type of the first record
            if len(self.domain_names) == 0 and record_type != 'A':
                QMessageBox.critical(self, "Error", "The first record must have type 'A'")
                return

            # Validating the domain name
            if not self.validate_domain_name(name):
                QMessageBox.critical(self, "Error", "Invalid domain name")
                return

            # Validating the IP address for 'A' record type
            if record_type == 'A' and not self.validate_ip_address(value):
                QMessageBox.critical(self, "Error", "Invalid IP address")
                return

            # Getting the selected parent domain
            parent_domain = self.parent_domain_combo.currentText()

            # If a parent domain is selected, append its name to the record name separated by a dot
            if parent_domain:
                name = f"{name}.{parent_domain}"

            # Creating a new tree item
            item = QTreeWidgetItem([name, record_type, value])

            # If a parent domain is selected, add the record as a child to the selected parent
            if parent_domain:
                parent_item = self.domain_items.get(parent_domain)
                if parent_item:
                    parent_item.addChild(item)

            # If no parent domain is selected, add the record as a top-level item
            else:
                self.tree_widget.addTopLevelItem(item)

            # Adding the domain name to the Parent Domain combobox
            self.parent_domain_combo.addItem(name)

            # Adding the domain name to the list
            self.domain_names.append(name)

            # Adding the item to the domain_items dictionary
            self.domain_items[name] = item

        except ValueError as e:
            self.display_error_message(str(e))
            return
        except Exception as e:
            error_message = f"An error occurred while adding the record: {str(e)}"
            self.display_error_message(error_message)
            traceback.print_exc()



    def show_context_menu(self, pos):
        # Создание контекстного меню
        context_menu = QMenu(self)
        delete_action = QAction("Удалить", self)
        delete_action.triggered.connect(self.delete_record)
        context_menu.addAction(delete_action)

        # Определение позиции контекстного меню
        header_height = self.tree_widget.header().height()
        context_menu.exec_(self.tree_widget.viewport().mapToGlobal(pos + QtCore.QPoint(0, header_height)))

    def delete_record(self):
        # Получение выбранной записи
        selected_item = self.tree_widget.currentItem()

        if selected_item is None:
            return

        # Получение имени выбранной записи
        selected_name = selected_item.text(0)

        # Удаление записи из дерева
        parent = selected_item.parent()
        if parent:
            parent.removeChild(selected_item)
        else:
            self.tree_widget.invisibleRootItem().removeChild(selected_item)

        # Удаление имени выбранной записи из combobox Родительский домен
        self.parent_domain_combo.removeItem(self.parent_domain_combo.findText(selected_name))

        # Удаление имени выбранной записи из списка
        self.domain_names.remove(selected_name)




    def get_tree_item_by_name(self, name):
        # Поиск элемента дерева по имени
        root = self.tree_widget.invisibleRootItem()
        for i in range(root.childCount()):
            item = root.child(i)
            if item.text(0) == name:
                return item
        return None

    def generate_json(self):
        root = self.tree_widget.invisibleRootItem()
        data = self.get_tree_data(root)
        json_data = json.dumps(data, indent=4)

        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Save JSON File",
            "",
            "JSON Files (*.json)"
        )
        if file_path:
            with open(file_path, "w") as file:
                file.write(json_data)

    def open_image_window(self):
        try:
            root = self.tree_widget.invisibleRootItem()
            data = self.get_tree_data(root)

            edges = []

            def get_edges(treedict, parent=None):
                for item in treedict:
                    if isinstance(item, dict):
                        name = item['name'].replace('"', r'\"').replace('\\', r'\\')
                        if parent is not None and parent != "":
                            edges.append((parent, name))
                        if "children" in item and isinstance(item['children'], list):
                            get_edges(item['children'], parent=name)
                    else:
                        edges.append((parent, item))

            get_edges(data)
            print(data)
            output = 'strict digraph tree {\n'
            for row in edges:
                output += '    "{0}" -> "{1}";\n'.format(*row)
            output += '}'
            print(output)
            graph = graphviz.Source(output)
            graph.render(filename='graph', format='png', cleanup=True)
            image_path = "graph.png"  # Замените на фактический путь к изображению
            image_viewer = ImageViewer(image_path)
            image_viewer.exec_()

        except Exception as e:
            print("Произошла ошибка:", str(e))

    def validate_domain_name(self, name):
        # Check if name contains only alphanumeric characters and dots (if records exist)
        if self.domain_names:
            pattern = r'^[a-zA-Zа-яА-Я0-9.]+$'
            return re.match(pattern, name)

        # If no records exist, allow any character, including dots
        return True

    def validate_ip_address(self, ip_address):
        ip_regex = re.compile(
            r"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
        )
        return bool(ip_regex.match(ip_address))


    def display_error_message(self, error_message):
        QMessageBox.critical(self, "Error", error_message)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = DNSZoneEditor()
    window.show()
    sys.exit(app.exec_())
