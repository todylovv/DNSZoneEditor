import sys
import json
import traceback

import graphviz
from PyQt5.QtCore import QRegExp
from PyQt5.QtGui import QRegExpValidator, QValidator, QPixmap, QIcon, QPalette, QColor
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QVBoxLayout, QWidget, QLabel, QLineEdit, QComboBox, QPushButton,
    QTreeWidget, QTreeWidgetItem, QMessageBox, QFileDialog, QGraphicsView, QGraphicsScene, QDialog, QStyleFactory,
    QMenu, QAction
)
from PyQt5 import QtCore, QtGui, QtWidgets
import paramiko
from paramiko.client import SSHClient, AutoAddPolicy
from paramiko.sftp_client import SFTPClient


class DNSZoneEditor(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("DNS Zone Editor")

        QApplication.setStyle(QStyleFactory.create("Fusion"))
        palette = QPalette()
        palette.setColor(QPalette.Window, QColor(225, 230, 237))
        palette.setColor(QPalette.WindowText, QColor(70, 70, 70))
        palette.setColor(QPalette.Base, QColor(255, 255, 255))
        palette.setColor(QPalette.AlternateBase, QColor(240, 245, 252))
        palette.setColor(QPalette.Button, QColor(220, 225, 232))
        palette.setColor(QPalette.ButtonText, QColor(70, 70, 70))
        palette.setColor(QPalette.Highlight, QColor(135, 170, 213))
        palette.setColor(QPalette.HighlightedText, QColor(255, 255, 255))
        QApplication.setPalette(palette)


        # Create line edits
        self.save_button = QPushButton("Save")
        self.save_button.clicked.connect(self.save_zone)

        self.parent_domain_combo = QComboBox()
        self.name_edit = QLineEdit()
        self.type_combo = QComboBox()
        self.value_edit = QLineEdit()

        self.type_combo.addItems(["A", "TXT", "CNAME"])

        self.add_button = QPushButton("Add")
        self.add_button.clicked.connect(self.add_record)

        self.tree_widget = QTreeWidget()
        self.tree_widget.setHeaderLabels(["Domain", "Type", "Value"])

        self.domain_hierarchy = {}

        layout = QVBoxLayout()

        form_layout = QVBoxLayout()
        form_layout.addWidget(QLabel("Parent Domain:"))
        form_layout.addWidget(self.parent_domain_combo)
        form_layout.addWidget(QLabel("Name:"))
        form_layout.addWidget(self.name_edit)
        form_layout.addWidget(QLabel("Type:"))
        form_layout.addWidget(self.type_combo)
        form_layout.addWidget(QLabel("Value:"))
        form_layout.addWidget(self.value_edit)
        form_layout.addWidget(self.add_button)

        form_widget = QWidget()
        form_widget.setLayout(form_layout)

        layout.addWidget(form_widget)
        layout.addWidget(self.tree_widget)

        layout.addWidget(self.save_button)


        central_widget = QWidget()
        central_widget.setLayout(layout)
        self.setCentralWidget(central_widget)

        self.domain_names = []

        self.tree_widget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.tree_widget.customContextMenuRequested.connect(self.show_context_menu)

    def save_zone(self):
        try:
            # Получите данные из дерева записей
            root = self.tree_widget.invisibleRootItem()
            data = self.get_tree_data(root)

            def dict_to_dns_zone(domain, data):
                # Создайте пустой список для хранения строк записей зоны DNS
                zone_lines = []

                # Пройдитесь по данным и создайте строку записи для каждой записи
                for entry in data:
                    name = entry['name']
                    record_type = entry['type']
                    value = entry['value']
                    zone_line = f"{name} IN {record_type} {value}"
                    zone_lines.append(zone_line)

                return zone_lines

            parent_domain = data[0]['name']
            domain = data[0]['name']
            print(parent_domain)

            zone_file_lines = []
            zone_file_lines.append("$TTL 604800")
            zone_file_lines.append(f"@ IN SOA ns1.{parent_domain}. hostmaster.{parent_domain}. (")
            zone_file_lines.append("    2023052901 ; Serial")
            zone_file_lines.append("    3600       ; Refresh")
            zone_file_lines.append("    1800       ; Retry")
            zone_file_lines.append("    604800     ; Expire")
            zone_file_lines.append("    86400      ; Negative Cache TTL")
            zone_file_lines.append(")")
            zone_file_lines.append(f"@ IN ns ns1.{parent_domain}.")
            zone_file_lines.append("")
            zone_file_lines.append("ns1 IN A 192.168.0.100")
            zone_file_lines.append(f"{parent_domain} IN A 192.168.31.1")

            zone_file_lines.extend(dict_to_dns_zone(domain, data))
            zone_file_content = '\n'.join(zone_file_lines)
            zone_file_content += '\n'

            print(zone_file_content)

            import paramiko

            # SSH connection parameters
            hostname = '192.168.31.159'
            username = 'aleks'
            password = '12345'
            port = 22

            # SSH client initialization
            client = paramiko.SSHClient()
            client.load_system_host_keys()  # Load system host keys
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

            try:
                # Connect to the Ubuntu server
                client.connect(hostname, port, username, password)

                # Remove the existing helloworld.com.zone file if it exists
                _, stdout, stderr = client.exec_command('rm /etc/bind/zones/{}.zone'.format(parent_domain))
                print(stdout.read().decode())
                print(stderr.read().decode())

                # Define the DNS zone content
                dns_zone_content = zone_file_content

                # Create a temporary file to store the DNS zone content
                with open('dns_zone.txt', 'w') as zone_file:
                    zone_file.write(dns_zone_content)

                # Upload the file to the remote server
                transport = client.get_transport()
                sftp = paramiko.SFTPClient.from_transport(transport)
                sftp.put('dns_zone.txt', '/etc/bind/zones/{}.zone'.format(parent_domain))
                sftp.close()

                # Read the content of named.conf.default-zones
                _, stdout, _ = client.exec_command('cat /etc/bind/named.conf.local')
                named_conf_default_zones_content = stdout.read().decode()

                # Check if the zone configuration already exists in named.conf.default-zones
                if f'zone "{parent_domain}.com"' in named_conf_default_zones_content:
                    print('Zone configuration already exists in named.conf.default-zones. Skipping...')
                else:
                    # Add zone configuration to named.conf.default-zones
                    append_command = f'echo \'zone "{parent_domain}" {{ type master; file "/etc/bind/zones/{parent_domain}.zone"; }};\' | sudo -S tee -a /etc/bind/named.conf.local '

                    _, stdout, stderr = client.exec_command(append_command)
                    print(stdout.read().decode())
                    print(stderr.read().decode())

                    # Execute the command to restart the DNS server
                    _, stdout, stderr = client.exec_command('sudo systemctl restart bind9')
                    print(stdout.read().decode())
                    print(stderr.read().decode())

            except Exception as e:
                error_message = f"An error occurred while saving the zone: {str(e)}"
                self.display_error_message(error_message)
                traceback.print_exc()

            finally:
                if client:
                    client.close()

            print(data)  # Пример вывода данных

        except Exception as e:
            error_message = f"An error occurred while saving the zone: {str(e)}"
            self.display_error_message(error_message)
            traceback.print_exc()

    def get_tree_data(self, parent_item):
        data = []
        for i in range(parent_item.childCount()):
            item = parent_item.child(i)
            name = item.text(0)
            record_type = item.text(1)
            value = item.text(2)
            children = self.get_tree_data(item)
            data.append({
                'name': name,
                'type': record_type,
                'value': value,
                'children': children
            })
        return data
    def add_record(self):
        try:
            # Получение значений из элементов интерфейса
            name = self.name_edit.text()
            record_type = self.type_combo.currentText()
            value = self.value_edit.text()

            # Проверка типа первой записи
            if len(self.domain_names) == 0 and record_type != 'A':
                QMessageBox.critical(self, "Ошибка", "Первая запись должна иметь тип 'A'")
                return

            # Получение выбранного родительского домена
            parent_domain = self.parent_domain_combo.currentText()

            # Если выбран родитель, добавляем его имя к имени записи через точку
            if parent_domain:
                name = f"{name}.{parent_domain}"

            # Создание нового элемента дерева
            item = QTreeWidgetItem([name, record_type, value])

            # Если выбран родитель, добавляем запись как дочернюю для выбранного родителя
            if parent_domain:
                parent_item = self.get_tree_item_by_name(parent_domain)
                if parent_item:
                    parent_item.addChild(item)

            # Если не выбран родитель, добавляем запись как верхний уровень дерева
            else:
                self.tree_widget.addTopLevelItem(item)

            # Добавление имени домена в combobox Родительский домен
            self.parent_domain_combo.addItem(name)

            # Добавление имени домена в список
            self.domain_names.append(name)
        except ValueError as e:
            self.display_error_message(str(e))
            return
        except Exception as e:
            error_message = f"An error occurred while adding the record: {str(e)}"
            self.display_error_message(error_message)
            traceback.print_exc()

    def show_context_menu(self, pos):
        # Создание контекстного меню
        context_menu = QMenu(self)
        delete_action = QAction("Удалить", self)
        delete_action.triggered.connect(self.delete_record)
        context_menu.addAction(delete_action)

        # Определение позиции контекстного меню
        header_height = self.tree_widget.header().height()
        context_menu.exec_(self.tree_widget.viewport().mapToGlobal(pos + QtCore.QPoint(0, header_height)))

    def delete_record(self):
        # Получение выбранной записи
        selected_item = self.tree_widget.currentItem()

        if selected_item is None:
            return

        # Получение имени выбранной записи
        selected_name = selected_item.text(0)

        # Удаление записи из дерева
        parent = selected_item.parent()
        if parent:
            parent.removeChild(selected_item)
        else:
            self.tree_widget.invisibleRootItem().removeChild(selected_item)

        # Удаление имени выбранной записи из combobox Родительский домен
        self.parent_domain_combo.removeItem(self.parent_domain_combo.findText(selected_name))

        # Удаление имени выбранной записи из списка
        self.domain_names.remove(selected_name)




    def get_tree_item_by_name(self, name):
        # Поиск элемента дерева по имени
        root = self.tree_widget.invisibleRootItem()
        for i in range(root.childCount()):
            item = root.child(i)
            if item.text(0) == name:
                return item
        return None

    def validate_ip_address(self, ip_address):
        ip_regex = QRegExp(
            r"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
        )
        ip_validator = QRegExpValidator(ip_regex, self)

        if ip_validator.validate(ip_address, 0)[0] == QValidator.Acceptable:
            return True
        else:
            return False

    def display_error_message(self, error_message):
        QMessageBox.critical(self, "Error", error_message)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = DNSZoneEditor()
    window.show()
    sys.exit(app.exec_())
